from sage.all import GF
# from - https://github.com/tl2cents/AEAD-Nonce-Reuse-Attacks
# from - https://github.com/jvdsn/crypto-attacks/blob/master/attacks/gcm/forbidden_attack.py


x = GF(2)["x"].gen()
gf2e = GF(2 ** 128, name="y", modulus=x ** 128 + x ** 7 + x ** 2 + x + 1)


def xor(b1,b2):
    return bytes([i^j for i,j in zip(b1,b2)])

# Converts an integer to a gf2e element, little endian.
def _to_gf2e(n):
    return gf2e([(n >> i) & 1 for i in range(127, -1, -1)])


# Converts a gf2e element to an integer, little endian.
def _from_gf2e(p):
    n = p.integer_representation()
    ans = 0
    for i in range(128):
        ans <<= 1
        ans |= ((n >> i) & 1)
    return int(ans)


# Calculates the GHASH polynomial.
def _ghash(h, a, c, const_coeff=gf2e(0)):
    """
    Calculates the GHASH polynomial with given authentication key h, associated data a, and ciphertext c.

    Args:
        h (gf2e element): the authentication key
        a (bytes): the associated data
        c (bytes): the ciphertext
        const_coeff(gf2e) : the constant coefficient of the GHASH polynomial

    Returns:
        gf2e element: the (hash) value of the evaluated polynomial.
    """
    la = len(a)
    lc = len(c)
    p = gf2e(0)
    for i in range(la // 16):
        p += _to_gf2e(int.from_bytes(a[16 * i:16 * (i + 1)], byteorder="big"))
        p *= h

    if la % 16 != 0:
        p += _to_gf2e(int.from_bytes(a[-(la % 16):] + bytes(16 - la % 16), byteorder="big"))
        p *= h

    for i in range(lc // 16):
        p += _to_gf2e(int.from_bytes(c[16 * i:16 * (i + 1)], byteorder="big"))
        p *= h

    if lc % 16 != 0:
        p += _to_gf2e(int.from_bytes(c[-(lc % 16):] + bytes(16 - lc % 16), byteorder="big"))
        p *= h

    p += _to_gf2e(((8 * la) << 64) | (8 * lc))
    p *= h
    p += const_coeff
    return p


def recover_possible_auth_keys(a1, c1, t1, 
                               a2, c2, t2):
    """
    Recovers possible authentication keys from two messages encrypted with the same authentication key.
    More information: Joux A., "Authentication Failures in NIST version of GCM"
    :param a1: the associated data of the first message (bytes)
    :param c1: the ciphertext of the first message (bytes)
    :param t1: the authentication tag of the first message (bytes)
    :param a2: the associated data of the second message (bytes)
    :param c2: the ciphertext of the second message (bytes)
    :param t2: the authentication tag of the second message (bytes)
    :return: a generator generating possible authentication keys (gf2e element)
    """
    h = gf2e["h"].gen()
    p1 = _ghash(h, a1, c1) + _to_gf2e(int.from_bytes(t1, byteorder="big"))
    p2 = _ghash(h, a2, c2) + _to_gf2e(int.from_bytes(t2, byteorder="big"))
    for h, _ in (p1 + p2).roots():
        yield h


def forge_tag_from_ciphertext(h, a, c, t, target_a, target_c):
    """
    Forges an authentication tag for a target message given a message with a known tag.
    This method is best used with the authentication keys generated by the recover_possible_auth_keys method.
    More information: Joux A., "Authentication Failures in NIST version of GCM"
    :param h: the authentication key to use (gf2e element)
    :param a: the associated data of the message with the known tag (bytes)
    :param c: the ciphertext of the message with the known tag (bytes)
    :param t: the known authentication tag (bytes)
    :param target_a: the target associated data (bytes)
    :param target_c: the target ciphertext (bytes)
    :return: the forged authentication tag (bytes)
    """
    ghash = _from_gf2e(_ghash(h, a, c))
    target_ghash = _from_gf2e(_ghash(h, target_a, target_c))
    return int(ghash ^ int.from_bytes(t, byteorder="big") ^ target_ghash).to_bytes(16, byteorder="big")

def forge_tag_from_plaintext(h, a, c, t, m, target_a, target_msg):
    """
    Forges an authentication tag for a target message given a message with a known tag.
    This method is best used with the authentication keys generated by the recover_possible_auth_keys method.
    More information: Joux A., "Authentication Failures in NIST version of GCM"
    :param h: the authentication key to use (gf2e element)
    :param a: the associated data of the message with the known tag (bytes)
    :param c: the ciphertext of the message with the known tag (bytes)
    :param t: the known authentication tag (bytes)
    :param m: the known plaintex of c (bytes)
    :param target_a: the target associated data (bytes)
    :param target_msg: the target message (bytes)
    :return: (the forged ciphertext (bytes), the forged authentication tag (bytes))
    """
    assert len(m) >= len(target_msg), "The length of the known plaintext should be at least the length of the target message"
    target_c = xor(xor(c, m),target_msg)
    return target_c, forge_tag_from_ciphertext(h, a, c, t, target_a, target_c)

def aes_gcm_forgery_attack(a1:bytes, c1:bytes, t1:bytes,
                           a2:bytes, c2:bytes, t2:bytes,
                           known_plaintext1:bytes,
                           target_msg:bytes, target_a:bytes):
    """
    AES-GCM Authentication Tag Forgery Attack. The pair (a1,c1,t1) and (a2,c2,t2) are the known ciphertexts and tags 
    encrypted with the same key and nonce. Forges a tag for the target message with the associated data target_a.
    If no known plaintext is available, set known_plaintext1 to c1, and you can forge the tag 
    with the target message being the ciphertext (not the plaintext).

    Args:
        a1 (bytes): the associated data of the first message
        c1 (bytes): the ciphertext of the first message
        t1 (bytes): the authentication tag of the first message
        a2 (bytes): the associated data of the second message
        c2 (bytes): the ciphertext of the second message
        t2 (bytes): the authentication tag of the second message
        known_plaintext1 (bytes): the known plaintext of c1
        target_msg (bytes): the target message
        target_a (bytes): the associated data of the target message
        
    Returns:
        bytes, bytes: the forged ciphertext and the forged authentication tag
    """
    for h in recover_possible_auth_keys(a1, c1, t1, a2, c2, t2):
        yield forge_tag_from_plaintext(h, a1, c1, t1, known_plaintext1, target_a, target_msg)
        
def is_valid_h(h, a, c, t, const_coeff):
    """
    Check if the authentication key h is valid for the message (a,c,t)

    Args:
        h (gf2e element): the authentication key
        a (bytes): the associated data of the message
        c (bytes): the ciphertext of the message
        t (bytes): the authentication tag of the message
        const_coeff (gf2e element): the constant coefficient of the GHASH polynomial

    Returns:
        bool: True if the authentication key is valid, False otherwise
    """
    return _from_gf2e(_ghash(h, a, c, const_coeff)) == int.from_bytes(t, byteorder="big")
        

def aes_gcm_forgery_attack_general(ads, cts, tags, 
                                   known_plaintext1, 
                                   target_msg, target_a):
    """
    AES-GCM Authentication Tag Forgery Attack. The list of (ads,cts,tags) are the known ciphertexts and tags 
    encrypted with the same key and nonce. Forges a unique tag for the target message with the associated data target_a.
    If no known plaintext is available, set known_plaintext1 to c1, and you can forge the tag 
    with the target message being the ciphertext (not the plaintext).
    
    Args:
        ads (List[bytes]): the associated data of the messages
        cts (List[bytes]): the ciphertexts of the messages
        tags (List[bytes]): the authentication tags of the messages
        known_plaintext1 (bytes): the known plaintext of c1
        target_msg (bytes): the target message
        target_a (bytes): the associated data of the target message
        
    Returns:
        bytes: the forged ciphertext and the forged authentication tag
    """
    assert len(ads) == len(cts) == len(tags) and len(ads) > 1, "The number of messages should be at least 2"
    hs = list(recover_possible_auth_keys(ads[0], cts[0], tags[0], ads[1], cts[1], tags[1]))
    print(f"[+] Found {len(hs)} possible keys from the first two messages")
    valid_keys = []
    for h in hs:
        const_coeff = _ghash(h, ads[0], cts[0]) - _to_gf2e(int.from_bytes(tags[0], byteorder="big"))
        if all(is_valid_h(h, a, c, t, const_coeff) for a,c,t in zip(ads, cts, tags)):
            valid_keys.append(h)
    if len(valid_keys) == 0:
        print(f"[+] No valid keys found, check whether the ciphertexts are encrypted with the same key and nonce")
        raise ValueError("No valid keys found")
    elif len(valid_keys) > 1:
        print(f"[+] Found {len(valid_keys)} valid keys, the attack may not be unique")
    return forge_tag_from_plaintext(valid_keys[0], ads[0], cts[0], tags[0], known_plaintext1, target_a, target_msg)